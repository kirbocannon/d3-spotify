{% extends 'base.html' %}

{% block extendedImportedScripts %}

<!-- Import Custom CSS -->
<link href="../static/css/visualization.css" rel="stylesheet">

{% endblock extendedImportedScripts %}

{% block content %}

<style>
    form {
        font-family: "Helvetica Neue", Helvetica, Arial, sans-serif;
    }

    svg {
        font: 11px Arial;
        box-shadow: 0 4px 8px 0 rgba(0, 0, 0, 2), 0 6px 20px 0 rgba(0, 0, 0, 0.40);
        display: block;
        margin: auto;
        margin-top: 120px;
        padding-left: 120px;
    }

    .row {
        margin-top: 10px;
    }

    .center {
        margin: auto;
        width: 100%;
        padding: 10px
    }

    #playlistSelect {
    }

    .select2-normal {
    }

    .select2-selection {
        padding-bottom: 8px;
        box-shadow: 6px 6px 5px -5px rgba(0,0,0,0.75);
    }

</style>

<div class="row">
     <div class="col-xl-12">
         <div class="container">
               <select class="center" id="playlistSelect" name="playlists[]" multiple="multiple"></select>
         </div>
     </div>
</div>

  <div class="row">
    <div class="col-xl-12">
    <div class="container" id="svgContainer">

        <svg class="center" width="960" height="800" ></svg>
    </div>
    </div>
  </div>

<!-- Import ds3 -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/d3/5.12.0/d3.min.js"></script>

<!-- Import select2 -->
<link href="https://cdn.jsdelivr.net/npm/select2@4.0.12/dist/css/select2.min.css" rel="stylesheet" />
<script src="https://cdn.jsdelivr.net/npm/select2@4.0.12/dist/js/select2.min.js"></script>

<script>

const graphDataPath = "/data/output.json";
const nodeImageSize = 45;
const svg = d3.select("svg");
const width = +svg.attr("width");
const height = +svg.attr("height");
const color = d3.scaleOrdinal(d3.schemeCategory10);
const edgeAlign = -20;
const nodeGroupMap = {
    'playlist': {'color': "#7f7f7f", 'group': 1},
    'track': {'color': "#ff7f0e", 'group': 5}
};

d3.json(graphDataPath).then(function(graph) {

    const simulation = d3.forceSimulation()
    .force("nodeLink", d3.forceLink().id(function(d) { return d.id; }).distance(1).strength(.01)) // set link strength and distance
    .force("charge", d3.forceManyBody().strength(-500).distanceMax(100).distanceMin(50)) // spread nodes apart by modifying gravity aka attraction
    //.force("y", d3.forceY(height*0.7)/4) // determine y-axis hierarchy by group
//        if(d.group === "1"){
//            return (height*0.7)/4
//       } else if (d.group === "2"){
//            return 2*(height*0.7)/4
//        } else if (d.group === "3"){
//            return 3*(height*0.7)/4
//        } else {
//            return 0
//        }
//     }).strength(1)) // y-axis link strength
    .force("x", d3.forceX(width/2)) // forces attraction towards specified point
    .force("center", d3.forceCenter((width*1.1)/2, height/2))
    .force("collision", d3.forceCollide().radius(.2)) // treat nodes as circles with radius rather than points, prevent overlapping of nodes

    //add encompassing group for the zoom
    const g = svg.append("g")
        .attr("class", "everything");

    let links = g.append("g")
        .selectAll("line")
        .data(graph.links) // get json data
        .enter().append("line") // apply data and add line to DOM
        .attr("stroke", "#00b8ff")
        //.attr("stroke-width", function(d) { return (Math.sqrt(d.value)) + 2; });
        //.attr("stroke", function(d) { return color(parseInt(d.value)); }) // color of links based on group
        //.attr("stroke-width", function(d) { return Math.sqrt(parseInt(d.value)); }); // width of lines based on group value by sqauring the value
        .attr("stroke-width", 2)

    let nodes = g.append("g")
        .attr("class", "nodes")
        .selectAll("g")
        .data(graph.nodes) // get json data
        .enter().append("g"); // enter represents elements to be added, add them to the DOM
        //.attr("target", '_blank')
        //.attr("xlink:href",  function(d) { return (window.location.href + '?device=' + d.id) }); // link for node details

    const tooltip = d3.select("body")
        .append("div")
        .attr("class", "popover")
        .style("opacity", 0);

    // keep track of clicked nodes
    let nodeClicked = false;
    let nodeClickedObj = '';

    nodes.on("click", function(d,i){
      d3.event.preventDefault();
      d3.event.stopPropagation();
      //d3.OnClickDetails(d.id);
      }
    );

    nodes.call(d3.drag() // leaving ability to drag nodess out for now
           .on("start", dragstarted)
           .on("drag", dragged)
           .on("end", dragended));

    nodes.append("circle") // add node icons
        .attr("r", function(d){return 30 / nodeGroupMap[d.nodeType]['group']})
        .attr("fill", function(d){return nodeGroupMap[d.nodeType]['color']})

    drawText();

    // node.append("title")
    //     .text(function(d) { return d.id; });

    //const loading = svg.append("text")
    //    .attr("dy", "0.35em")
    //    .attr("text-anchor", "middle")
    //    .attr("font-family", "sans-serif")
    //    .attr("font-size", 10)
    //    .text("Simulating. One moment pleaseâ€¦");

    simulation
        .nodes(graph.nodes)
        .on("tick", ticked);

    simulation
      .force("nodeLink")
      .links(graph.links);

    d3.timeout(function() { // synchronize animation with page load
        //loading.remove();
        // not sure exactly how this works, needs research
        for (let i = 0, n = Math.ceil(Math.log(simulation.alphaMin()) / Math.log(1 - simulation.alphaDecay())); i < n; ++i) {
            simulation.tick();
      }
    });

    // invoke timer callbacks, avoid flicker
    d3.timerFlush();

    function ticked() { // as simulation advances, .on tick called will display the results as computations process a 'tick'
        links
            .attr("x1", function(d) { return d.source.x; })
            .attr("y1", function(d) { return d.source.y; })
            .attr("x2", function(d) { return d.target.x; })
            .attr("y2", function(d) { return d.target.y; });

        nodes
            .attr("transform", function(d) { return "translate(" + d.x + "," + d.y + ")"});
    }

    function dragstarted(d) {
       if (!d3.event.active) simulation.alphaTarget(0.3).restart();
       d.fx = d.x;
       d.fy = d.y;
     }

    function dragged(d) {
       d.fx = d3.event.x;
       d.fy = d3.event.y;
     }

    function dragended(d) {
       if (!d3.event.active) simulation.alphaTarget(0);
       d.fx = null;
       d.fy = null;
     }

    // PAN/ZOOM FUNCTIONALITY
    const zoom_handler = d3.zoom()
        .on("zoom", zoom_actions);

    zoom_handler(svg);

    // disable double-click to zoom
    svg.on("dblclick.zoom", null);

    // pan/zoom functions
    function zoom_actions() {
        g.attr("transform", d3.event.transform)
    }

    function drawText() {
        nodes.append("text")
            //.attr("font-size", function(d){return `${2 / nodeGroupMap[d.nodeType]['group']}em`})
            .attr("id", function(d){return "label-" + d.id})
            .attr("font-weight", "Bold")
            .style('fill', '#95A3B3') // put in logic for a 'healthy' vs 'unhealthy' node
            .attr("dx", -30)
            .attr("dy", function(d){return `${4.8 / nodeGroupMap[d.nodeType]['group']}em`})
            .attr("x", +10)
            .text(function(d) { return d.id });
    }

    function update() {
        //nodes
        //    .data(graph.nodes.slice(0,300));
        //nodes
        //    .enter().append("g");
        nodes
            .data([])
            .exit()
            .remove();

        // restart simulation
        //simulation
            //.alphaTarget(.7)
          //  .restart();
    }

    function updateGraphWithPlaylists() {
       // let selectedPlaylists = $('#playlistSelect').val();
       // let selectedPlaylists = ['Scores'];
        let selectedPlaylists = ['Scores', 'Trance']
        let nodesToKeep = [];
        let linksToKeep = [];
        graph.nodes.forEach(function(entry) {
            // if select playlists equal node id
            if (entry.nodeType === 'playlist' && selectedPlaylists.indexOf(entry.id) > -1) {
                nodesToKeep.push(entry);
            }
            else if (entry.nodeType === 'track') {
                // check if selected playlists are in playlists in node
                let pcnt = 0;
                entry.playlists.forEach(function(p) {
                    if (selectedPlaylists.indexOf(p) > -1) {
                        pcnt += 1;
                    }

                });

                if (pcnt === entry.playlists.length) {
                    nodesToKeep.push(entry)
                }
            }
        });
        graph.links.forEach(function(entry) {
            // if entry's target is not found in playlists selected
            if (selectedPlaylists.indexOf(entry.target.id) > -1) {
                linksToKeep.push(entry)
            }
        })


        console.log(nodesToKeep, 'nodes')
        console.log(linksToKeep, 'links')


        //nodes.exit()
        //    .remove();

        //nodes = g.append("g")
        //    .attr("class", "nodes")
        //    .selectAll("g")
        //    .data(graph.nodes, function(d) {return d.id}) // get json data
        //    //.enter().append("g"); // enter represents elements to be added, add them to the DOM
        //    .exit().remove()

        //console.log(nodesToRemove)

        nodes = nodes.data(nodesToKeep, function(d){return d.id});
        nodes.exit().remove();
        nodes = nodes
            .enter()
            .attr("r", function(d){return 30 / nodeGroupMap[d.nodeType]['group']})
            .attr("fill", function(d){return nodeGroupMap[d.nodeType]['color']})
            .merge(nodes);

       links = links.data(linksToKeep, function(d) { return d.source.id + "-" + d.target.id; });
       links.exit().remove();
       links = links
           .enter()
           .append("line")
           .merge(links)
           .attr("stroke", "#00b8ff")
           .attr("stroke-width", 2);

        //nodes
        //    .data(nodesToRemove)
        //    .exit()
        //    .remove();

        //links
        //    .data(linksToRemove)
        //    .exit()
        //    .remove()

        simulation.nodes(nodes);
        simulation.force("nodeLink").links(links);
        simulation.alpha(.7).restart();

    }

    updateGraphWithPlaylists()

    //update()

});

/*
$(".pop").popover({ trigger: "manual" , html: true, animation:false})
    .on("mouseenter", function () {
        let _this = this;
        $(this).popover("show");
        $(".popover").on("mouseleave", function () {
            $(_this).popover('hide');
        });
    }).on("mouseleave", function () {
        let _this = this;
        setTimeout(function () {
            if (!$(".popover:hover").length) {
                $(_this).popover("hide");
            }
        }, 300);

});*/

$(document).ready(function() {
    const $playlistSelect = $('#playlistSelect').select2({
        placeholder: "Select Playlists...",
        width: "100%",
        closeOnSelect: false,
        allowClear: true,
        tags: true,
        tokenSeparators: [','],
        ajax: {
            url: graphDataPath,
            type: "get",
            dataType: "json",
            processResults: function(data) {
                let playlists = [];
                data['nodes'].forEach(function(node){
                    if (node.nodeType === 'playlist') {
                        playlists.push({id: node.id, text: node.id})
                    }
                });
                return {
                    results: playlists,
                    pagination: {
                        more: false
                    }
                };
            }
        }
    });

    // add custom select2 class
    $playlistSelect.data('select2').$container.addClass("select2-normal")
});

</script>

{% endblock content %}

