{% extends 'base.html' %}

{% block extendedImportedScripts %}

<!-- Import Custom CSS -->
<link href="../static/css/visualization.css" rel="stylesheet">

{% endblock extendedImportedScripts %}

{% block content %}

<style>
    form {
        font-family: "Helvetica Neue", Helvetica, Arial, sans-serif;
    }

    svg {
        font: 11px Arial;
        display: block;
        margin: auto;

    }

    #svgContainer {
        box-shadow: 0 4px 8px 0 rgba(0, 0, 0, 2), 0 6px 20px 0 rgba(0, 0, 0, 0.40);
    }

    .row {
        margin-top: 10px;
    }

    .center {
        margin: auto;
        width: 100%;
        padding: 10px
    }

    #playlistSelect {
    }

    .select2-normal {
    }

    .select2-selection {
        padding-bottom: 8px;
        box-shadow: 6px 6px 5px -5px rgba(0,0,0,0.75);
    }

</style>

<div class="row">
     <div class="col-xl-12">
         <div class="container center">
               <select class="center" id="playlistSelect" name="playlists[]" multiple="multiple"></select>
         </div>
     </div>
</div>

  <div class="row">
    <div class="col-xl-12">
    <div class="container center" id="svgContainer">
        <div class="container" id="loadingCircleContainer"></div>
        <svg id="svgWindow" class="center" width="960" height="800" ></svg>
    </div>
    </div>
  </div>

<!-- Import ds3 -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/d3/5.12.0/d3.min.js"></script>

<!-- Import select2 -->
<link href="https://cdn.jsdelivr.net/npm/select2@4.0.12/dist/css/select2.min.css" rel="stylesheet" />
<script src="https://cdn.jsdelivr.net/npm/select2@4.0.12/dist/js/select2.min.js"></script>

<script>

let graph = {};
const graphDataPath = "/data/output.json";
const nodeImageSize = 45;
const linkedByIndex = {};
const width = 960;
const height = 600;
const svg = d3.select("svg")
    //.attr("viewBox", [-width / 2, -height / 2, width, height]);
    .attr("viewbox", [width, height])
//add encompassing group for the zoom
const g = svg.append("g")
    .attr("class", "everything");
//add zoom capabilities
const zoom_handler = d3.zoom()
    .on("zoom", zoom_actions);
const edgeAlign = -20;
const nodeGroupMap = {
    'playlist': {'color': "#7f7f7f", "group": 1},
    'track': {'color': "#ff7f0e", "mcolor": "#2cff1c", "group": 5}
};

let links = g.append("g")
    .selectAll("line");

let nodes = g.append("g")
    .selectAll("circle");

let nodeLabels = g.append("g")
    .selectAll("text");

//const loadingCircleElement = document.createElement('div');
//loadingCircleElement.setAttribute('id', 'loadingCircle')
//loadingCircleElement.setAttribute('class', 'spinner-border')
//loadingCircleElement.setAttribute('role', 'status')
//loadingCircleElement.innerHTML =`<span class="sr-only">Loading...</span>`

//const loadingCircleContainer = document.getElementById("loadingCircleContainer");

//svgContainer.insertBefore(loadingCircleElement, svgContainer.childNodes[0])
//loadingCircleContainer.appendChild(loadingCircleElement)
let simulation = Object
let labelLayout = Object

d3.json(graphDataPath).then(function(g) {

    graph = g;
    startGraph();

});

function startGraph() {

    simulation = d3.forceSimulation(graph.nodes)
        //.force("center", d3.forceCenter(width / 2, height / 2))
        //.force("nodeLink", d3.forceLink().id(d => d.id).strength(.1)) // set link strength and distance
        //.force("charge", d3.forceManyBody().strength(-500).distanceMax(100).distanceMin(50)) // spread nodes apart by modifying gravity aka attraction
        .force("collision", d3.forceCollide().radius(5)) // treat nodes as circles with radius rather than points, prevent overlapping of nodes
      .force("nodeLink", d3.forceLink(graph.links).id(d => d.id))
      .force("charge", d3.forceManyBody().strength(-500))
      .force("x", d3.forceX())
      .force("y", d3.forceY());

    links = links
        //.data(graph.links) // get json data
        .data([]) // get json data
        .enter()
        .append("line") // apply data and add line to DOM
        //.on('mouseover.fade', linkFade(.3))
        //.on('mouseout.fade', linkFade(1))
        .attr("class", "link")
        .attr("stroke", "#00b8ff")
        .attr("stroke-width", 2)

    nodes = nodes
        //.data(graph.nodes) // get json data
        .data([]) // get json data
        .enter()
        .append("circle") // enter represents elements to be added, add them to the DOM
        .attr("class", "node")
        .attr("r", function(d){return 30 / nodeGroupMap[d.nodeType]['group']})
        .attr("fill", function(d){return nodeGroupMap[d.nodeType]['color']})
        .on('mouseover.fade', nodeFade(.3))
        .on('mouseout.fade', nodeFade(1))

    nodes = nodes.call(d3.drag() // ability to drag elements
           .on("start", dragstarted)
           .on("drag", dragged)
           .on("end", dragended));

    nodeLabels = nodeLabels
        .attr("class", "text")
        //.text(function(d) { return d.node.id })
        //.data(graph.nodes)
        .data([])
        .enter()
        .append("text")
        .text(d => d.id)
        .attr("id", function(d){return "label-" + d.id})
        .attr("font-weight", "Bold")
        .style('fill', '#000000')
       // .style("font-family", "Arial")
        .style("font-size", 12)
        //.attr("x", 8)
        //.attr("y", ".31em")
        .attr("dx", -30)
        .attr("dy", function(d){return `${4.8 / nodeGroupMap[d.nodeType].group}em`})
        //.attr("x", +10)
        .on('mouseover.fade', nodeFade(.3))
        .on('mouseout.fade', nodeFade(1))

    simulation
        .on("tick", ticked);

    zoom_handler(svg);

    // keep track of who is connected to who
    graph.links.forEach((d) => {
        linkedByIndex[`${d.source.index},${d.target.index}`] = 1;
    });

}

function ticked() { // as simulation advances, .on tick called will display the results as computations process a 'tick'
    links
        .attr("x1", d => d.source.x)
        .attr("y1", d => d.source.y)
        .attr("x2", d => d.target.x)
        .attr("y2", d => d.target.y);

    nodes
        .attr("cx", d => d.x)
        .attr("cy", d => d.y)
        // commenting out for now but these would restrain nodes within viewbox
        //.attr("cx", function(d) { return d.x = Math.max(radius, Math.min(width - radius, d.x)); })
        //.attr("cy", function(d) { return d.y = Math.max(radius, Math.min(height - radius, d.y)); });

    nodeLabels
        .attr("x", d => d.x - 5) //position of the lower left point of the text
        .attr("y", d => d.y + 5); //position of the lower left point of the text
}

function dragstarted(d) {
   if (!d3.event.active) simulation.alphaTarget(0.3).restart();
   d.fx = d.x;
   d.fy = d.y;
 }

function dragged(d) {
   d.fx = d3.event.x;
   d.fy = d3.event.y;
 }

function dragended(d) {
   if (!d3.event.active) simulation.alphaTarget(0);
   d.fx = null;
   d.fy = null;
 }

//Zoom functions
function zoom_actions(){
    g.attr("transform", d3.event.transform)
}

function isConnected(a, b) {
    return linkedByIndex[`${a.index},${b.index}`] || linkedByIndex[`${b.index},${a.index}`] || a.index === b.index;
}

//Fade rules for hovering over nodes
function nodeFade(opacity) {
    return d => {
      nodes.style('stroke-opacity', function (o) {
        const thisOpacity = isConnected(d, o) ? 1 : opacity;
        this.setAttribute('fill-opacity', thisOpacity);
        return thisOpacity;
      });

      links.style('stroke-opacity', o => (o.source === d || o.target === d ? 1 : opacity));

    };
}

function linkFade(opacity) {
    return d => {
      nodes.style('stroke-opacity', function (o) {
        const thisOpacity = isConnected(d, o) ? 1 : opacity;
        this.setAttribute('fill-opacity', thisOpacity);
        return thisOpacity;
      });

    links.style('stroke-opacity', o => (o.source === d.source && o.target === d.target ? 1 : opacity));

    }
}

function updateGraphWithPlaylists() {
    let selectedPlaylists = $('#playlistSelect').val();
    //let selectedPlaylists = ['Scores', "Trance"];
    const nodesToKeep = [];
    const linksToKeep = [];
    graph.nodes.forEach(function(entry, i) {
        // if select playlists equal node id
        if (entry.nodeType === 'playlist' && selectedPlaylists.indexOf(entry.id) > -1) {
            nodesToKeep.push(entry);
        }
        else if (entry.nodeType === 'track') {
            // check if selected playlists are in playlists in node
            for (let i=0; i < entry.playlists.length; i++) {
                if (selectedPlaylists.indexOf(entry.playlists[i]) > -1) {
                    nodesToKeep.push(entry);
                    break
                }
            }
        }
    });

    graph.links.forEach(function(entry) {
        // if entry's target is found in playlists selected
        if (selectedPlaylists.indexOf(entry.target.id) > -1) {
            linksToKeep.push(entry)
        }
    });

    // remove previous nodes
    nodes = nodes.data(nodesToKeep, function(d){return d.id});
    nodeLabels = nodeLabels.data(nodesToKeep, function(d){return d.id});
    links = links.data(linksToKeep, function(d) { return d.source.id + "-" + d.target.id; });

    nodes.exit().remove();
    nodeLabels.exit().remove();
    links.exit().remove();

    nodes = nodes
        .enter()
        .append("circle") // enter represents elements to be added, add them to the DOM
        .attr("class", "node")
        .attr("r", function(d){return 30 / nodeGroupMap[d.nodeType]['group']})
        .on('mouseover.fade', nodeFade(.3))
        .on('mouseout.fade', nodeFade(1))
        //.attr("r", function(d){return 30 / nodeGroupMap[d.nodeType]['group']})
        //.attr("fill", function(d){return nodeGroupMap[d.nodeType]['color']})
        .call(d3.drag()
            .on("start", dragstarted)
            .on("drag", dragged)
            .on("end", dragended))
        .merge(nodes);

    // need this separate to apply after all nodes are in the DOM
    nodes
        .attr("fill", function(d){
        if (d.nodeType === 'track' && d.playlists.length > 1) {
            let playlists_found = 0;
            new Set(d.playlists).forEach((p) => {
                if (selectedPlaylists.indexOf(p) > -1) playlists_found += 1
            });
            console.log(playlists_found > 1 ? nodeGroupMap[d.nodeType]['mcolor']: nodeGroupMap[d.nodeType]['color'])
            return (playlists_found > 1 ? nodeGroupMap[d.nodeType]['mcolor']: nodeGroupMap[d.nodeType]['color'])
        } else {
            return nodeGroupMap[d.nodeType]['color']
        }
    });

    nodeLabels = nodeLabels
        .attr("class", "text")
        .data(nodesToKeep)
        .enter()
        .append("text")
        .text(d => d.id)
        .attr("id", d => {return "label-" + d.id})
        .attr("font-weight", "Bold")
        .style('fill', '#000000')
       // .style("font-family", "Arial")
        .style("font-size", 12)
        .attr("dx", -20)
        .attr("dy", function(d){return `${4.8 / nodeGroupMap[d.nodeType].group}em`})
        .on('mouseover.fade', nodeFade(.3))
        .on('mouseout.fade', nodeFade(1))
        .merge(nodeLabels);

   links = links
       .enter()
       .append("line")
       //.on('mouseover.fade', linkFade(.3))
       //.on('mouseout.fade', linkFade(1))
       .merge(links)
       .attr("stroke", "#00b8ff")
       .attr("stroke-width", 2)

    simulation.alpha(.1).restart();
}

$(document).ready(function() {
    const $playlistSelect = $('#playlistSelect').select2({
        placeholder: "Select Playlists...",
        width: "100%",
        closeOnSelect: true,
        allowClear: true,
        tags: true,
        tokenSeparators: [','],
        ajax: {
            url: graphDataPath,
            type: "get",
            dataType: "json",
            processResults: function(data) {
                let playlists = [];
                data['nodes'].forEach(function(node){
                    if (node.nodeType === 'playlist') {
                        playlists.push({id: node.id, text: node.id})
                    }
                });
                return {
                    results: playlists,
                    pagination: {
                        more: false
                    }
                };
            }
        }
    });

    // add custom select2 class
    $playlistSelect.data('select2').$container.addClass("select2-normal")

    $playlistSelect.on("change", function(e) {
        updateGraphWithPlaylists()
    });
});

</script>

{% endblock content %}

