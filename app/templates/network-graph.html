{% extends 'base.html' %}

{% block extendedImportedScripts %}

<!-- Import Custom CSS -->
<link href="../static/css/visualization.css" rel="stylesheet">

{% endblock extendedImportedScripts %}

{% block content %}

<style>
    form {
        font-family: "Helvetica Neue", Helvetica, Arial, sans-serif;
    }

    svg {
        font: 11px Arial;
        box-shadow: 0 4px 8px 0 rgba(0, 0, 0, 2), 0 6px 20px 0 rgba(0, 0, 0, 0.40);
        display: block;
        margin: auto;
        margin-top: 120px;
        padding-left: 120px;
    }

    .row {
        margin-top: 10px;
    }

    .center {
        margin: auto;
        width: 100%;
        padding: 10px
    }

    #playlistSelect {
    }

    .select2-normal {
    }

    .select2-selection {
        padding-bottom: 8px;
        box-shadow: 6px 6px 5px -5px rgba(0,0,0,0.75);
    }

</style>

<div class="row">
     <div class="col-xl-12">
         <div class="container">
               <select class="center" id="playlistSelect" name="playlists[]" multiple="multiple"></select>
         </div>
     </div>
</div>

  <div class="row">
    <div class="col-xl-12">
    <div class="container" id="svgContainer">

        <svg class="center" width="960" height="800" ></svg>
    </div>
    </div>
  </div>

<!-- Import ds3 -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/d3/5.12.0/d3.min.js"></script>

<!-- Import select2 -->
<link href="https://cdn.jsdelivr.net/npm/select2@4.0.12/dist/css/select2.min.css" rel="stylesheet" />
<script src="https://cdn.jsdelivr.net/npm/select2@4.0.12/dist/js/select2.min.js"></script>

<script>

let graph = {}
const graphDataPath = "/data/output.json";
const nodeImageSize = 45;
const svg = d3.select("svg");
const width = +svg.attr("width");
const height = +svg.attr("height");
const color = d3.scaleOrdinal(d3.schemeCategory10);
const edgeAlign = -20;
const nodeGroupMap = {
    'playlist': {'color': "#7f7f7f", "group": 1},
    'track': {'color': "#ff7f0e", "mcolor": "#2cff1c", "group": 5}
};
//add encompassing group for the zoom
const g = svg.append("g")
    .attr("class", "everything");

let links = g.append("g")
    .selectAll("line")

let nodes = g.append("g")
    .selectAll("g")

const simulation = d3.forceSimulation()
    .force("nodeLink", d3.forceLink().id(function(d) { return d.id; }).distance(1).strength(.01)) // set link strength and distance
    .force("charge", d3.forceManyBody().strength(-500).distanceMax(100).distanceMin(100)) // spread nodes apart by modifying gravity aka attraction
    .force("x", d3.forceX(width/2)) // forces attraction towards specified point
    .force("center", d3.forceCenter((width*1.1)/2, height/2))
    .force("collision", d3.forceCollide().radius(.2)) // treat nodes as circles with radius rather than points, prevent overlapping of nodes

d3.json(graphDataPath).then(function(g) {

    graph = g;
    startGraph()
    updateGraphWithPlaylists()

});

function startGraph() {

    links = links
        .data(graph.links) // get json data
        .enter().append("line") // apply data and add line to DOM
        .attr("stroke", "#00b8ff")
        .attr("stroke-width", 2)

    nodes = nodes
        .attr("class", "nodes")
        .data(graph.nodes) // get json data
        .enter().append("g"); // enter represents elements to be added, add them to the DOM

    nodes = nodes.call(d3.drag() // ability to drag elements
           .on("start", dragstarted)
           .on("drag", dragged)
           .on("end", dragended));

    nodes.append("circle") // add node icons
        .attr("r", function(d){return 30 / nodeGroupMap[d.nodeType]['group']})
        .attr("fill", function(d){
            if (d.nodeType === 'track' && d.playlists.length > 1) {
                return nodeGroupMap[d.nodeType]['mcolor']
            } else {
                return nodeGroupMap[d.nodeType]['color']
            }
        });

    drawText();

    simulation
        .nodes(graph.nodes)
        .on("tick", ticked);

    simulation
      .force("nodeLink")
      .links(graph.links);

    d3.timeout(function() { // synchronize animation with page load
        // not sure exactly how this works, needs research
        for (let i = 0, n = Math.ceil(Math.log(simulation.alphaMin()) / Math.log(1 - simulation.alphaDecay())); i < n; ++i) {
            simulation.tick();
      }
    });

    // invoke timer callbacks, avoid flicker
    d3.timerFlush();

    // PAN/ZOOM FUNCTIONALITY
    const zoom_handler = d3.zoom()
        .on("zoom", zoom_actions);

    zoom_handler(svg);

    // disable double-click to zoom
    svg.on("dblclick.zoom", null);

}

function ticked() { // as simulation advances, .on tick called will display the results as computations process a 'tick'
    links
        .attr("x1", function(d) { return d.source.x; })
        .attr("y1", function(d) { return d.source.y; })
        .attr("x2", function(d) { return d.target.x; })
        .attr("y2", function(d) { return d.target.y; });

    nodes
        .attr("transform", function(d) { return "translate(" + d.x + "," + d.y + ")"});
}

function dragstarted(d) {
   if (!d3.event.active) simulation.alphaTarget(0.3).restart();
   d.fx = d.x;
   d.fy = d.y;
 }

function dragged(d) {
   d.fx = d3.event.x;
   d.fy = d3.event.y;
 }

function dragended(d) {
   if (!d3.event.active) simulation.alphaTarget(0);
   d.fx = null;
   d.fy = null;
 }

// pan/zoom functions
function zoom_actions() {
    g.attr("transform", d3.event.transform)
}

function drawText() {
    nodes.append("text")
        //.attr("font-size", function(d){return `${2 / nodeGroupMap[d.nodeType]['group']}em`})
        .attr("id", function(d){return "label-" + d.id})
        .attr("font-weight", "Bold")
        .style('fill', '#95A3B3') // put in logic for a 'healthy' vs 'unhealthy' node
        .attr("dx", -30)
        .attr("dy", function(d){return `${4.8 / nodeGroupMap[d.nodeType]['group']}em`})
        .attr("x", +10)
        .text(function(d) { return d.id });
}

function updateGraphWithPlaylists() {
   // let selectedPlaylists = $('#playlistSelect').val();
    let selectedPlaylists = ['Scores', "Trance"];
    let nodesToKeep = [];
    let linksToKeep = [];
    graph.nodes.forEach(function(entry) {
        // if select playlists equal node id
        if (entry.nodeType === 'playlist' && selectedPlaylists.indexOf(entry.id) > -1) {
            nodesToKeep.push(entry);
        }
        else if (entry.nodeType === 'track') {
            // check if selected playlists are in playlists in node
            for (let i=0; i < entry.playlists.length; i++) {
                if (selectedPlaylists.indexOf(entry.playlists[i]) > -1) {
                    nodesToKeep.push(entry);
                    break
                }
            }
        }
    });
    graph.links.forEach(function(entry) {
        // if entry's target is found in playlists selected
        if (selectedPlaylists.indexOf(entry.target.id) > -1) {
            linksToKeep.push(entry)
        }
    })

    console.log(nodesToKeep, 'nodes')
    console.log(linksToKeep, 'links')

    nodes = nodes.data(nodesToKeep, function(d){return d.id});
    nodes.exit().remove();

    //nodes = nodes
    //    .enter().append("g")
    //    .attr("r", function(d){return 30 / nodeGroupMap[d.nodeType]['group']})
    //    .attr("fill", function(d){return nodeGroupMap[d.nodeType]['color']})
    //    .call(d3.drag()
    //        .on("start", dragstarted)
    //        .on("drag", dragged)
    //        .on("end", dragended))
    //    .merge(nodes);

   links = links.data(linksToKeep, function(d) { return d.source.id + "-" + d.target.id; });
   links.exit().remove();
   links = links
       .enter()
       .append("line")
       .merge(links)
       .attr("stroke", "#00b8ff")
       .attr("stroke-width", 2);

    //simulation.nodes(nodes);
    simulation.force("nodeLink").links(links);
    simulation.alpha(.5).restart();
}


$(document).ready(function() {
    const $playlistSelect = $('#playlistSelect').select2({
        placeholder: "Select Playlists...",
        width: "100%",
        closeOnSelect: false,
        allowClear: true,
        tags: true,
        tokenSeparators: [','],
        ajax: {
            url: graphDataPath,
            type: "get",
            dataType: "json",
            processResults: function(data) {
                let playlists = [];
                data['nodes'].forEach(function(node){
                    if (node.nodeType === 'playlist') {
                        playlists.push({id: node.id, text: node.id})
                    }
                });
                return {
                    results: playlists,
                    pagination: {
                        more: false
                    }
                };
            }
        }
    });

    // add custom select2 class
    $playlistSelect.data('select2').$container.addClass("select2-normal")
});

</script>

{% endblock content %}

