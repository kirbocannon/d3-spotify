{% extends 'base.html' %}

{% block extendedImportedScripts %}

<!-- Import Custom CSS -->
<link href="../static/css/visualization.css" rel="stylesheet">

{% endblock extendedImportedScripts %}

{% block content %}

<style>
    form {
        font-family: "Helvetica Neue", Helvetica, Arial, sans-serif;
    }

    svg {
        font: 11px Arial;
        box-shadow: 0 4px 8px 0 rgba(0, 0, 0, 2), 0 6px 20px 0 rgba(0, 0, 0, 0.40);
        display: block;
        margin: auto;
        margin-top: 120px;
        padding-left: 120px;
    }

    .row {
        margin-top: 10px;
    }

    .center {
        margin: auto;
        width: 100%;
        padding: 10px
    }

    #playlistSelect {
    }

    .select2-normal {
    }

    .select2-selection {
        padding-bottom: 8px;
        box-shadow: 6px 6px 5px -5px rgba(0,0,0,0.75);
    }

</style>

<div class="row">
     <div class="col-xl-12">
         <div class="container">
               <select class="center" id="playlistSelect" name="playlists[]" multiple="multiple"></select>
         </div>
     </div>
</div>

  <div class="row">
    <div class="col-xl-12">
    <div class="container" id="svgContainer">

        <svg class="center" width="960" height="800" ></svg>
    </div>
    </div>
  </div>

<!-- Import ds3 -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/d3/5.12.0/d3.min.js"></script>

<!-- Import select2 -->
<link href="https://cdn.jsdelivr.net/npm/select2@4.0.12/dist/css/select2.min.css" rel="stylesheet" />
<script src="https://cdn.jsdelivr.net/npm/select2@4.0.12/dist/js/select2.min.js"></script>

<script>

let graph = {};
const graphDataPath = "/data/output.json";
const nodeImageSize = 45;
const svg = d3.select("svg");
const linkedByIndex = {};
const width = +svg.attr("width");
const height = +svg.attr("height");
const simulation = d3.forceSimulation();
const edgeAlign = -20;
const nodeGroupMap = {
    'playlist': {'color': "#7f7f7f", "group": 1},
    'track': {'color': "#ff7f0e", "mcolor": "#2cff1c", "group": 5}
};
//add encompassing group for the zoom
const g = svg.append("g")
    .attr("class", "everything");

let links = g.append("g")
    .selectAll("line")

let nodes = g.append("g")
    .selectAll("g")

d3.json(graphDataPath).then(function(g) {

    graph = g;
    startGraph();

});

function startGraph() {

    links = links
        .data(graph.links) // get json data
        //.data([]) // get json data
        .enter().append("line") // apply data and add line to DOM
        //.on('mouseover.fade', linkFade(0))
        //.on('mouseout.fade', linkFade(1))
        .attr("class", "link")
        .attr("stroke", "#00b8ff")
        .attr("stroke-width", 2)

    nodes = nodes
        .attr("class", "node")
        //.attr("opacity", 1)
        .data(graph.nodes) // get json data
        //.data([]) // get json data
        .enter().append("g") // enter represents elements to be added, add them to the DOM
        .on('mouseover.fade', nodeFade(0))
        .on('mouseout.fade', nodeFade(1))
       // .on('mouseover', function(d) {
       //     d3.select(this).transition()
       //         .duration('50')
       //         .attr("opacity", .85)
       // })
        //.on('mouseout', function(d) {
         //   d3.select(this).transition()
        //        .duration('50')
        //        .attr("opacity", 1)
        //})

    nodes = nodes.call(d3.drag() // ability to drag elements
           .on("start", dragstarted)
           .on("drag", dragged)
           .on("end", dragended));

    nodes.append("circle") // add node icons
        .attr("r", function(d){return 30 / nodeGroupMap[d.nodeType]['group']})
        .attr("fill", function(d){return nodeGroupMap[d.nodeType]['color']});

    drawText();

    simulation
        //.force("nodeLink", d3.forceLink(links).id(d => d.id))
      //.force("charge", d3.forceManyBody())
      .force("center", d3.forceCenter(width / 2, height / 2))

        .force("nodeLink", d3.forceLink().id(d => d.id).strength(.1)) // set link strength and distance
    .force("charge", d3.forceManyBody().strength(-500).distanceMax(100).distanceMin(50)) // spread nodes apart by modifying gravity aka attraction
       // .force("x", d3.forceX(width/10)) // forces attraction towards specified point
    //.force("center", d3.forceCenter((width*1.1)/2, height/2))
    .force("collision", d3.forceCollide().radius(20)) // treat nodes as circles with radius rather than points, prevent overlapping of nodes

    simulation
        .nodes(graph.nodes)
        .on("tick", ticked);

    simulation
      .force("nodeLink")
      .links(graph.links);

   d3.timeout(function() { // synchronize animation with page load
        // not sure exactly how this works, needs research
        for (let i = 0, n = Math.ceil(Math.log(simulation.alphaMin()) / Math.log(1 - simulation.alphaDecay())); i < n; ++i) {
            simulation.tick();
      }
    });

    // invoke timer callbacks, avoid flicker
    d3.timerFlush();

    // PAN/ZOOM FUNCTIONALITY
    const zoom_handler = d3.zoom()
        .on("zoom", zoom_actions);

    zoom_handler(svg);

    // disable double-click to zoom
    svg.on("dblclick.zoom", null);

    graph.links.forEach((d) => {
        linkedByIndex[`${d.source.index},${d.target.index}`] = 1;
    });

}

function ticked() { // as simulation advances, .on tick called will display the results as computations process a 'tick'
    links
        .attr("x1", d => d.source.x)
        .attr("y1", d => d.source.y)
        .attr("x2", d => d.target.x)
        .attr("y2", d => d.target.y);

    nodes
        .attr("transform", (d) => { return "translate(" + d.x + "," + d.y + ")"});
}

function dragstarted(d) {
   if (!d3.event.active) simulation.alphaTarget(0.3).restart();
   d.fx = d.x;
   d.fy = d.y;
 }

function dragged(d) {
   d.fx = d3.event.x;
   d.fy = d3.event.y;
 }

function dragended(d) {
   if (!d3.event.active) simulation.alphaTarget(0);
   d.fx = null;
   d.fy = null;
 }

// pan/zoom functions
function zoom_actions() {
    g.attr("transform", d3.event.transform)
}

function drawText() {
    nodes.append("text")
        //.attr("font-size", function(d){return `${2 / nodeGroupMap[d.nodeType]['group']}em`})
        .attr("id", function(d){return "label-" + d.id})
        .attr("font-weight", "Bold")
        .style('fill', '#95A3B3') // put in logic for a 'healthy' vs 'unhealthy' node
        .attr("dx", -30)
        .attr("dy", function(d){return `${4.8 / nodeGroupMap[d.nodeType]['group']}em`})
        .attr("x", +10)
        .text(function(d) { return d.id });
}

function isConnected(a, b) {
    return linkedByIndex[`${a.index},${b.index}`] || linkedByIndex[`${b.index},${a.index}`] || a.index === b.index;
}

//Fade rules for hovering over nodes
function nodeFade(opacity) {
    return d => {
      nodes.style('stroke-opacity', function (o) {
        const thisOpacity = isConnected(d, o) ? 1 : opacity;
        this.setAttribute('fill-opacity', thisOpacity);
        return thisOpacity;
      });

      links.style('stroke-opacity', o => (o.source === d || o.target === d ? 1 : opacity));

    };
}

function linkFade(opacity) {
    return d => {
      nodes.style('stroke-opacity', function (o) {
          //console.log(d, o)
        const thisOpacity = isConnected(d, o) ? 1 : opacity;
        console.log(thisOpacity)
        this.setAttribute('fill-opacity', thisOpacity);
        return thisOpacity;
      });

    links.style('stroke-opacity', o => (o.source === d.source && o.target === d.target ? 1 : opacity));

    }
}

function updateGraphWithPlaylists() {
    let selectedPlaylists = $('#playlistSelect').val();
    console.log(selectedPlaylists)
    //let selectedPlaylists = ['Scores', "Trance"];
    let nodesToKeep = [];
    let linksToKeep = [];
    graph.nodes.forEach(function(entry) {
        // if select playlists equal node id
        if (entry.nodeType === 'playlist' && selectedPlaylists.indexOf(entry.id) > -1) {
            nodesToKeep.push(entry);
        }
        else if (entry.nodeType === 'track') {
            // check if selected playlists are in playlists in node
            for (let i=0; i < entry.playlists.length; i++) {
                if (selectedPlaylists.indexOf(entry.playlists[i]) > -1) {
                    nodesToKeep.push(entry);
                    break
                }
            }
        }
    });
    graph.links.forEach(function(entry) {
        // if entry's target is found in playlists selected
        if (selectedPlaylists.indexOf(entry.target.id) > -1) {
            linksToKeep.push(entry)
        }
    })

    console.log(nodesToKeep, 'nodes')
    console.log(linksToKeep, 'links')

    nodes = nodes.data(nodesToKeep, function(d){return d.id});
    nodes.exit().remove();

    nodes = nodes
        .enter().append("g")
        .attr("r", function(d){return 30 / nodeGroupMap[d.nodeType]['group']})
        .attr("fill", function(d){return nodeGroupMap[d.nodeType]['color']})
        .call(d3.drag()
            .on("start", dragstarted)
            .on("drag", dragged)
            .on("end", dragended))
        .merge(nodes);

    nodes.append("circle") // add node icons
        .attr("r", function(d){return 30 / nodeGroupMap[d.nodeType]['group']})
        .attr("fill", function(d){
            if (d.nodeType === 'track' && d.playlists.length > 1) {
                let playlists_found = 0;
                new Set(d.playlists).forEach((p) => {
                    if (selectedPlaylists.indexOf(p) > -1) playlists_found += 1
                });
                return (playlists_found > 1 ? nodeGroupMap[d.nodeType]['mcolor']: nodeGroupMap[d.nodeType]['color'])
            } else {
                return nodeGroupMap[d.nodeType]['color']
            }
        });

    drawText();

   links = links.data(linksToKeep, function(d) { return d.source.id + "-" + d.target.id; });
   links.exit().remove();
   links = links
       .enter()
       .append("line")
       .merge(links)
       .attr("stroke", "#00b8ff")
       .attr("stroke-width", 2)


    //simulation.nodes(nodes);
    simulation.force("nodeLink").links(links);
    simulation.alpha(.1).restart();
}


$(document).ready(function() {
    const $playlistSelect = $('#playlistSelect').select2({
        placeholder: "Select Playlists...",
        width: "100%",
        closeOnSelect: true,
        allowClear: true,
        tags: true,
        tokenSeparators: [','],
        ajax: {
            url: graphDataPath,
            type: "get",
            dataType: "json",
            processResults: function(data) {
                let playlists = [];
                data['nodes'].forEach(function(node){
                    if (node.nodeType === 'playlist') {
                        playlists.push({id: node.id, text: node.id})
                    }
                });
                return {
                    results: playlists,
                    pagination: {
                        more: false
                    }
                };
            }
        }
    });

    // add custom select2 class
    $playlistSelect.data('select2').$container.addClass("select2-normal")

    $playlistSelect.on("change", function(e) {
        updateGraphWithPlaylists()
    });
});

</script>

{% endblock content %}

