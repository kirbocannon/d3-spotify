{% extends 'base.html' %}

{% block extendedImportedScripts %}

<!-- Import Custom CSS -->
<link href="../static/css/visualization.css" rel="stylesheet">

{% endblock extendedImportedScripts %}

{% block content %}

<style>
    form {
        font-family: "Helvetica Neue", Helvetica, Arial, sans-serif;
    }

    svg {
        font: 11px Arial;
        display: block;
        margin: auto;

    }

    #svgContainer {
        box-shadow: 0 4px 8px 0 rgba(0, 0, 0, 2), 0 6px 20px 0 rgba(0, 0, 0, 0.40);
    }

    .row {
        margin-top: 10px;
    }

    .center {
        margin: auto;
        width: 100%;
        padding: 10px
    }

    #playlistSelect {
    }

    .select2-normal {
    }

    .select2-selection {
        padding-bottom: 8px;
        box-shadow: 6px 6px 5px -5px rgba(0,0,0,0.75);
    }

</style>

<div class="row">
     <div class="col-xl-12">
         <div class="container center">
               <select class="center" id="playlistSelect" name="playlists[]" multiple="multiple"></select>
         </div>
     </div>
</div>

  <div class="row">
    <div class="col-xl-12">
    <div class="container center" id="svgContainer">
        <!--<div class="container" id="loadingCircleContainer"></div>-->
        <svg id="svgWindow" class="center" width="960" height="800" ></svg>
    </div>
    </div>
  </div>

<!-- Import ds3 -->
<!--<script src="https://cdnjs.cloudflare.com/ajax/libs/d3/5.12.0/d3.min.js"></script>-->

<!-- Import select2 -->
<!--<link href="https://cdn.jsdelivr.net/npm/select2@4.0.12/dist/css/select2.min.css" rel="stylesheet" />-->
<!--<script src="https://cdn.jsdelivr.net/npm/select2@4.0.12/dist/js/select2.min.js"></script>-->

<!-- Import ds3 -->
<script src="{{ url_for('static', filename='js/d3.v5.min.js') }}"></script>

<!-- Import select2 -->
<link href="{{ url_for('static', filename='js/select2/select2.min.css') }}" rel="stylesheet" />
<script src="{{ url_for('static', filename='js/select2/select2.min.js') }}"></script>

<script>

const graphDataPath = "/data/spotifyData.json";

const width = 960,
    height = 800,
    radius = 6,
    linkedByIndex = {},
    nodeGroupMap = {
    'playlist': {'color': "#7f7f7f", "group": 1},
    'track': {'color': "#ff7f0e", "mcolor": "#2cff1c", "group": 5}
};

const svg = d3.select("svg").attr("viewbox", `0 0 ${width} ${height}`),
    zoom_handler = d3.zoom().on("zoom", zoom_actions);

const svgContainer = d3.select(svg.node().parentNode),
    g = svg.append("g").attr("class", "everything");

let links = g.append("g").selectAll("line");
let nodes = g.append("g").selectAll("circle");
let nodeLabels = g.append("g").selectAll("text");
let simulation = Object;
let labelLayout = Object;
let graph = {};

d3.json(graphDataPath).then(function(g) {

    graph = g;
    startGraph();
    //updateGraphWithPlaylists()

});

function startGraph() {

    simulation = d3.forceSimulation()
        .force("collision", d3.forceCollide().radius(radius).strength(.1)) // treat nodes as circles with radius rather than points, prevent overlapping of nodes
        .force("nodeLink", d3.forceLink().id(d => d.id))
        .force("charge", d3.forceManyBody().strength(-200))
        .force("x", d3.forceX().strength(.1).x(width * .5))
        .force("center", d3.forceCenter((width*0.7)/2, height/2))
        .force("y", d3.forceY().strength(.1).y(height * .5));
        //.velocityDecay(0.4)
        //.alphaTarget(0.1);

    links = links
        //.data(graph.links) // get json data
        .data([]) // get json data
        .enter()
        .append("line") // apply data and add line to DOM
        //.on('mouseover.fade', linkFade(.3))
        //.on('mouseout.fade', linkFade(1))
        .attr("class", "link")
        .attr("stroke", "#00b8ff")
        .attr("stroke-width", 2);

    nodes = nodes
        //.data(graph.nodes) // get json data
        .data([]) // get json data
        .enter()
        .append("circle") // enter represents elements to be added, add them to the DOM
        .attr("class", "node")
        .attr("r", function(d){return 30 / nodeGroupMap[d.nodeType]['group']})
        //.attr("fill", function(d){return nodeGroupMap[d.nodeType]['color']})
        .on('mouseover.fade', nodeFade(.3))
        .on('mouseout.fade', nodeFade(1))

    // need this separate to apply after all nodes are in the DOM
    nodes
        //.attr("fill", d => {return d.playlists.length || 0 > 1 ? nodeGroupMap[d.nodeType]['mcolor']: nodeGroupMap[d.nodeType]['color']})
        .attr("fill", d => {
            if (d.nodeType === 'track') {
                return d.playlists.length > 1 ? nodeGroupMap[d.nodeType]['mcolor']: nodeGroupMap[d.nodeType]['color']
            }
            else {
                return nodeGroupMap[d.nodeType]['color']
            }

        });

    nodes = nodes.call(d3.drag() // ability to drag elements
           .on("start", dragstarted)
           .on("drag", dragged)
           .on("end", dragended));

    nodeLabels = nodeLabels
        .attr("class", "text")
        //.text(function(d) { return d.node.id })
        //.data(graph.nodes)
        .data([])
        .enter()
        .append("text")
        .text(d => d.id)
        .attr("id", function(d){return "label-" + d.id})
        .attr("font-weight", (d => d.nodeType === 'playlist' ? "bold" : "normal"))
        .style('fill', '#000000')
        .style("font-family", "Arial")
        .style("font-size", (d => d.nodeType === 'track' ? 2 : 14))
        //.attr("x", 8)
        //.attr("y", ".31em")
        //.attr("dx", -30)
        //.attr("dy", function(d){return `${4.8 / nodeGroupMap[d.nodeType].group}em`})
        .on('mouseover.fade', nodeFade(.3))
        .on('mouseout.fade', nodeFade(1))

    simulation
        .nodes(graph.nodes)
        .on("tick", ticked);

    simulation.force("nodeLink")
        .links(graph.links);

    zoom_handler(svg);

}

function updateGraphWithPlaylists() {
    let selectedPlaylists = $('#playlistSelect').val();
    //let selectedPlaylists = ['Scores', "Trance"];
    //let selectedPlaylists = ['Dance']
    const nodesToKeep = [];
    const linksToKeep = [];

    graph.nodes.forEach(function(entry, i) {
        // if select playlists equal node id
        if (entry.nodeType === 'playlist' && selectedPlaylists.indexOf(entry.id) > -1) {
            nodesToKeep.push(entry);
        }
        else if (entry.nodeType === 'track') {
            // check if selected playlists are in playlists in node
            for (let i=0; i < entry.playlists.length; i++) {
                if (selectedPlaylists.indexOf(entry.playlists[i]) > -1) {
                    nodesToKeep.push(entry);
                    break
                }
            }
        }
    });

    // keep track of who is connected to who
    linksToKeep.forEach((d) => {
        linkedByIndex[`${d.source.index},${d.target.index}`] = 1;
    });

    graph.links.forEach(function(entry) {
        // if entry's target is found in playlists selected
        if (selectedPlaylists.indexOf(entry.target.id) > -1) {
            linksToKeep.push(entry)
        }
    });

    // add selected nodes
    nodes = nodes.data(nodesToKeep, d => {return d.id});
    nodeLabels = nodeLabels.data(nodesToKeep, d => {return d.id});
    links = links.data(linksToKeep, d => { return d.source.id + "-" + d.target.id; });

    // remove unselected nodes
    nodes.exit().remove();
    nodeLabels.exit().remove();
    links.exit().remove();

    nodes = nodes
        .enter()
        .append("circle") // enter represents elements to be added, add them to the DOM
        .attr("class", "node")
        .attr("r", function(d){return 30 / nodeGroupMap[d.nodeType]['group']})
        .on('mouseover.fade', nodeFade(.3))
        .on('mouseout.fade', nodeFade(1))
        .call(d3.drag()
            .on("start", dragstarted)
            .on("drag", dragged)
            .on("end", dragended))
        .merge(nodes);

    // need this separate to apply after all nodes are in the DOM
    nodes
        .attr("fill", function(d){
        if (d.nodeType === 'track' && d.playlists.length > 1) {
            let playlists_found = 0;
            new Set(d.playlists).forEach((p) => {
                if (selectedPlaylists.indexOf(p) > -1) playlists_found += 1
            });
            return (playlists_found > 1 ? nodeGroupMap[d.nodeType]['mcolor']: nodeGroupMap[d.nodeType]['color'])
        } else {
            return nodeGroupMap[d.nodeType]['color']
        }
    });

    nodeLabels = nodeLabels
        .attr("class", "text")
        .data(nodesToKeep)
        .enter()
        .append("text")
        .text(d => d.id)
        .attr("id", d => {return "label-" + d.id})
        .attr("font-weight", (d => d.nodeType === 'playlist' ? "bold" : "normal"))
        .style('fill', '#000000')
        .style("font-family", "Arial")
        .style("font-size", (d => d.nodeType === 'track' ? 7 : 12))
        .attr("dx", 10)
        .attr("dy", function(d){return `${4.8 / nodeGroupMap[d.nodeType].group}em`})
        .on('mouseover.fade', nodeFade(.3))
        .on('mouseout.fade', nodeFade(1))
        .merge(nodeLabels);

   links = links
       .enter()
       .append("line")
       //.on('mouseover.fade', linkFade(.3)) // this doesn't highlight the node that's connected yet
       //.on('mouseout.fade', linkFade(1))
       .merge(links)
       .attr("stroke", "#00b8ff")
       .attr("stroke-width", 2)

    simulation
        .nodes(nodesToKeep)
        .on("tick", ticked);

    simulation.force("nodeLink")
        .links(linksToKeep);

    simulation.alpha(.1).restart();
}

function ticked() { // as simulation advances, .on tick called will display the results as computations process a 'tick'
    links
        .attr("x1", d => d.source.x)
        .attr("y1", d => d.source.y)
        .attr("x2", d => d.target.x)
        .attr("y2", d => d.target.y);

    nodes
        .attr("cx", d => d.x)
        .attr("cy", d => d.y)
        // commenting out for now but these would restrain nodes within viewbox
        //.attr("cx", function(d) { return d.x = Math.max(radius, Math.min(width - radius, d.x)); })
        //.attr("cy", function(d) { return d.y = Math.max(radius, Math.min(height - radius, d.y)); });

    nodeLabels
        .attr("x", d => d.x - 15) //position of the lower left point of the text
        .attr("y", d => d.y + 15); //position of the lower left point of the text
}

function dragstarted(d) {
   if (!d3.event.active) simulation.alphaTarget(0.3).restart();
   d.fx = d.x;
   d.fy = d.y;
 }

function dragged(d) {
   d.fx = d3.event.x;
   d.fy = d3.event.y;
 }

function dragended(d) {
   if (!d3.event.active) simulation.alphaTarget(0);
   d.fx = null;
   d.fy = null;
 }

//Zoom functions
function zoom_actions(){
    g.attr("transform", d3.event.transform)
}

function isConnected(a, b) {
    return linkedByIndex[`${a.index},${b.index}`] || linkedByIndex[`${b.index},${a.index}`] || a.index === b.index;
}

//Fade rules for hovering over nodes
function nodeFade(opacity) {
    return d => {
      nodes.style('stroke-opacity', function (o) {
        const thisOpacity = isConnected(d, o) ? 1 : opacity;
        this.setAttribute('fill-opacity', thisOpacity);
        return thisOpacity;
      });

      links.style('stroke-opacity', o => (o.source === d || o.target === d ? 1 : opacity));
      nodeLabels.style('opacity', o => (o.id !== d.id ) ? opacity : 1 )

    };
}

/*
function linkFade(opacity) {
    return d => {
      nodes.style('stroke-opacity', function (o) {
        const thisOpacity = isConnected(d, o) ? 1 : opacity;
        this.setAttribute('fill-opacity', thisOpacity);
        return thisOpacity;
      });

    links.style('stroke-opacity', o => (o.source === d.source && o.target === d.target ? 1 : opacity));

    }
}
*/

$(document).ready(function() {
    const $playlistSelect = $('#playlistSelect').select2({
        placeholder: "Select Playlists...",
        width: "100%",
        closeOnSelect: true,
        allowClear: true,
        tags: true,
        tokenSeparators: [','],
        ajax: {
            url: graphDataPath,
            type: "get",
            dataType: "json",
            processResults: function(data) {
                let playlists = [];
                data['nodes'].forEach(function(node){
                    if (node.nodeType === 'playlist') {
                        playlists.push({id: node.id, text: node.id})
                    }
                });
                return {
                    results: playlists,
                    pagination: {
                        more: false
                    }
                };
            }
        }
    });

    // add custom select2 class
    $playlistSelect.data('select2').$container.addClass("select2-normal")

    $playlistSelect.on("change", function(e) {
        updateGraphWithPlaylists()
    });
});

</script>

{% endblock content %}

